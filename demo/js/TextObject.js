// Generated by CoffeeScript 1.8.0

/*
Poe.TextObject is the base on which all document children are made of.
It serves as a wrapper around a DOM element, in order to get away
from the nitty gritty details of the DOM. It is not intended
to be instantiated, but instead extended.
 */

(function() {
  Poe.TextObject = (function() {

    /*
    Creates a new Poe.TextObject.
    @note It is pointless to create a Poe.TextObject. It has no
    DOM element. Use a extension of it instead like {Poe.Word}, {Poe.Line},
    etc.
     */
    function TextObject() {
      this.children = [];
      this.element = null;
      this.parent = null;
    }


    /*
    Gets the child at index.
    @param index [Number] the index of the child
    @return [Poe.TextObject or null] the object if it exists
     */

    TextObject.prototype.child = function(index) {
      if (index >= 0 && index < this.children.length) {
        return this.children[index];
      }
      return null;
    };


    /*
    Gets the index of this in its parent's children.
    @throw [Error] If it is not found there is a bug somewhere
    @return [Number] the index. -1 if it has no parent
     */

    TextObject.prototype.index = function() {
      var index;
      if (!this.parent) {
        return -1;
      }
      index = this.parent.children.indexOf(this);
      if (index === -1) {
        throw new Error('Index should never be -1');
      }
      return index;
    };


    /*
    Inserts this after textObject. The parent is changed
    and this is added to the parents list of children. This change
    is also reflected in the DOM.
    @return [Poe.TextObject] this
     */

    TextObject.prototype.insertAfter = function(textObject) {
      if (textObject) {
        this.setParent(textObject.parent);
        this.parent.children.insertAfter(this, textObject);
        if (this.element && textObject.element) {
          textObject.element.after(this.element);
        }
      }
      return this;
    };


    /*
    Inserts this before textObject. The parent is changed and this is addded
    to the parents list of children. This change is reflected in the DOM.
    @return [Poe.TextObject] this
     */

    TextObject.prototype.insertBefore = function(textObject) {
      if (textObject) {
        this.setParent(textObject.parent);
        this.parent.children.insertAfter(this, textObject);
        if (this.element && textObject.element) {
          textObject.element.after(this.element);
        }
      }
      return this;
    };


    /*
    Appends textObject to children and adds it to the DOM.
    @param textObject [Poe.TextObject] the text object to append
    @return [Poe.TextObject] this
     */

    TextObject.prototype.append = function(textObject) {
      textObject.setParent(this);
      this.children.append(textObject);
      if (this.element) {
        this.element.append(textObject.element);
      }
      return this;
    };


    /*
    Prepends textObject to children and adds it to the DOM.
    @param textObject [Poe.TextObject] the text object to prepend
    @return [Poe.TextObject] this
     */

    TextObject.prototype.prepend = function(textObject) {
      textObject.setParent(this);
      this.children.prepend(textObject);
      if (this.element) {
        return this.element.prepend(textObject.element);
      }
    };


    /*
    Sets the parent of this to textObject, however it does not add itself
    to the parents list of children.
    @param textObject [Poe.TextObject] the new parent
    @return [Poe.TextObject] this
     */

    TextObject.prototype.setParent = function(textObject) {
      if (textObject) {
        if (this.parent) {
          this.parent.children.remove(this);
        }
        this.parent = textObject;
      }
      return this;
    };


    /*
    Removes this from DOM and parent's children. Also removes all
    children.
     */

    TextObject.prototype.remove = function() {
      var child, _i, _len, _ref;
      _ref = this.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        child.remove();
      }
      this.element.remove();
      return this.parent.children.remove(this);
    };

    TextObject.prototype.fromElement = function(element) {
      var child, ret, _i, _j, _len, _len1, _ref, _ref1;
      _ref = this.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        if (child.element[0] === element[0]) {
          return child;
        }
      }
      if (this.children) {
        _ref1 = this.children;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          child = _ref1[_j];
          ret = child.fromElement(element);
          if (ret !== null) {
            return ret;
          }
        }
      }
      return null;
    };


    /*
    Gets the next object in parents children and returns it
    @return [Poe.TextObject or null] next object if it exists
     */

    TextObject.prototype.next = function() {
      var next, _ref;
      next = this.parent.children.next(this);
      if (!next && this.parent instanceof Poe.TextObject) {
        next = (_ref = this.parent.next()) != null ? _ref.children.first() : void 0;
      }
      if (next) {
        return next;
      } else {
        return null;
      }
    };


    /*
    Gets the previous object in parents children and returns it
    @return [Poe.TextObject or null] previous object if it exists
     */

    TextObject.prototype.prev = function() {
      var prev, _ref;
      prev = this.parent.children.prev(this);
      if (!prev && this.parent instanceof Poe.TextObject) {
        prev = (_ref = this.parent.prev()) != null ? _ref.children.last() : void 0;
      }
      if (prev) {
        return prev;
      } else {
        return null;
      }
    };

    TextObject.prototype.nextSibling = function() {
      return this.parent.children.next(this);
    };

    TextObject.prototype.prevSibling = function() {
      return this.parent.children.prev(this);
    };


    /*
    Returns whether or not the object is empty of text
    @note Even though the {Poe.TextCursor} is not text. It does contain a
    text node. This will return false if there is a {Poe.TextCursor} somewhere
    in it's child tree.
    @return [Boolean] true if empty, false otherwise
     */

    TextObject.prototype.isEmpty = function() {
      if (this.element[0].textContent === '') {
        return true;
      }
      return false;
    };

    TextObject.prototype.position = function() {
      return this.element.position();
    };

    TextObject.prototype.height = function() {
      return this.element.height();
    };

    TextObject.prototype.width = function() {
      return this.element.width();
    };

    return TextObject;

  })();

}).call(this);

//# sourceMappingURL=TextObject.js.map
