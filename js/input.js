var characterMapShift = [];
characterMapShift[8] = "";
characterMapShift[9] = "";
characterMapShift[13] = "\n";
characterMapShift[16] = "";
characterMapShift[17] = "";
characterMapShift[18] = "";
characterMapShift[19] = "";
characterMapShift[20] = "";
characterMapShift[27] = "";
characterMapShift[32] = " ";
characterMapShift[33] = "";
characterMapShift[34] = "";
characterMapShift[35] = "";
characterMapShift[36] = "";
characterMapShift[37] = "";
characterMapShift[38] = "";
characterMapShift[39] = "";
characterMapShift[40] = "";
characterMapShift[45] = "";
characterMapShift[46] = "";
characterMapShift[48] = ")";
characterMapShift[49] = "!";
characterMapShift[50] = "@";
characterMapShift[51] = "#";
characterMapShift[52] = "$";
characterMapShift[53] = "%";
characterMapShift[54] = "^";
characterMapShift[55] = "&";
characterMapShift[56] = "*";
characterMapShift[57] = "(";
characterMapShift[59] = ":";
characterMapShift[61] = "+";
characterMapShift[65] = "A";
characterMapShift[66] = "B";
characterMapShift[67] = "C";
characterMapShift[68] = "D";
characterMapShift[69] = "E";
characterMapShift[70] = "F";
characterMapShift[71] = "G";
characterMapShift[72] = "H";
characterMapShift[73] = "I";
characterMapShift[74] = "J";
characterMapShift[75] = "K";
characterMapShift[76] = "L";
characterMapShift[77] = "M";
characterMapShift[78] = "N";
characterMapShift[79] = "O";
characterMapShift[80] = "P";
characterMapShift[81] = "Q";
characterMapShift[82] = "R";
characterMapShift[83] = "S";
characterMapShift[84] = "T";
characterMapShift[85] = "U";
characterMapShift[86] = "V";
characterMapShift[87] = "W";
characterMapShift[88] = "X";
characterMapShift[89] = "Y";
characterMapShift[90] = "Z";
characterMapShift[91] = "";
characterMapShift[92] = "";
characterMapShift[93] = "";
characterMapShift[96] = "0";
characterMapShift[97] = "1";
characterMapShift[98] = "2";
characterMapShift[99] = "3";
characterMapShift[100] = "4";
characterMapShift[101] = "5";
characterMapShift[102] = "6";
characterMapShift[103] = "7";
characterMapShift[104] = "8";
characterMapShift[105] = "9";
characterMapShift[106] = "*";
characterMapShift[107] = "+";
characterMapShift[109] = "_";
characterMapShift[107] = "+";
characterMapShift[111] = "/";
characterMapShift[112] = "";
characterMapShift[113] = "";
characterMapShift[114] = "";
characterMapShift[115] = "";
characterMapShift[116] = "";
characterMapShift[117] = "";
characterMapShift[118] = "";
characterMapShift[119] = "";
characterMapShift[120] = "";
characterMapShift[121] = "";
characterMapShift[122] = "";
characterMapShift[123] = "";
characterMapShift[144] = "";
characterMapShift[145] = "";
characterMapShift[186] = ":";
characterMapShift[187] = "+";
characterMapShift[188] = "<";
characterMapShift[189] = "_";
characterMapShift[190] = ">";
characterMapShift[191] = "?";
characterMapShift[192] = "~";
characterMapShift[219] = "{";
characterMapShift[220] = "|";
characterMapShift[221] = "}";
characterMapShift[222] = "\"";

var characterMap = [];
characterMap[8] = "";
characterMap[9] = "";
characterMap[13] = "\n";
characterMap[16] = "";
characterMap[17] = "";
characterMap[18] = "";
characterMap[19] = "";
characterMap[20] = "";
characterMap[27] = "";
characterMap[32] = " ";
characterMap[33] = "";
characterMap[34] = "";
characterMap[35] = "";
characterMap[36] = "";
characterMap[37] = "";
characterMap[38] = "";
characterMap[39] = "";
characterMap[40] = "";
characterMap[45] = "";
characterMap[46] = "";
characterMap[48] = "0";
characterMap[49] = "1";
characterMap[50] = "2";
characterMap[51] = "3";
characterMap[52] = "4";
characterMap[53] = "5";
characterMap[54] = "6";
characterMap[55] = "7";
characterMap[56] = "8";
characterMap[57] = "9";
characterMap[59] = ";";
characterMap[61] = "=";
characterMap[65] = "a";
characterMap[66] = "b";
characterMap[67] = "c";
characterMap[68] = "d";
characterMap[69] = "e";
characterMap[70] = "f";
characterMap[71] = "g";
characterMap[72] = "h";
characterMap[73] = "i";
characterMap[74] = "j";
characterMap[75] = "k";
characterMap[76] = "l";
characterMap[77] = "m";
characterMap[78] = "n";
characterMap[79] = "o";
characterMap[80] = "p";
characterMap[81] = "q";
characterMap[82] = "r";
characterMap[83] = "s";
characterMap[84] = "t";
characterMap[85] = "u";
characterMap[86] = "v";
characterMap[87] = "w";
characterMap[88] = "x";
characterMap[89] = "y";
characterMap[90] = "z";
characterMap[91] = "";
characterMap[92] = "";
characterMap[93] = "";
characterMap[96] = "0";
characterMap[97] = "1";
characterMap[98] = "2";
characterMap[99] = "3";
characterMap[100] = "4";
characterMap[101] = "5";
characterMap[102] = "6";
characterMap[103] = "7";
characterMap[104] = "8";
characterMap[105] = "9";
characterMap[106] = "*";
characterMap[107] = "+";
characterMap[109] = "_";
characterMap[107] = "+";
characterMap[111] = "/";
characterMap[112] = "";
characterMap[113] = "";
characterMap[114] = "";
characterMap[115] = "";
characterMap[116] = "";
characterMap[117] = "";
characterMap[118] = "";
characterMap[119] = "";
characterMap[120] = "";
characterMap[121] = "";
characterMap[122] = "";
characterMap[123] = "";
characterMap[144] = "";
characterMap[145] = "";
characterMap[186] = ";";
characterMap[187] = "=";
characterMap[188] = ",";
characterMap[189] = "-";
characterMap[190] = ".";
characterMap[191] = "/";
characterMap[192] = "`";
characterMap[219] = "[";
characterMap[220] = "\\";
characterMap[221] = "]";
characterMap[222] = "'";

/*
    Good website for getting the keycodes:
    http://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes
*/
var Key_Space = 32;
var Key_Backspace = 8;
var Key_Delete = 46;
var Key_Enter = 13;
var Key_Left = 37;
var Key_Right = 39;
var Key_Up = 38;
var Key_Down = 40;
var Key_Tab = 9;

var Word_Element = "<span class='word'></span>";

function mapKey(isShiftKey, characterCode) {
    if (typeof isShiftKey != "boolean" || typeof characterCode != "number") {
        return false;
    }

    if (isShiftKey) {
        return characterMapShift[characterCode];
    } else {
        return characterMap[characterCode];
    }
}

function CreateTextNode(text) {
    return document.createTextNode(text);
}

/*
    Splits the word span in two at the contained $node.
    $node should be a jQuery object to a child node
    that represents the halfway point.
    
    Callback should be a function accepting two arguments
    the first part of the split, and the second part
    and jQuery elements
*/
function splitAt($node, callback) {
    var $before = $(Word_Element);
    var $after = $(Word_Element);

    $node.parent().before($before);
    $node.parent().after($after);

    var sibling = $node[0].previousSibling;
    var other;
    while (sibling !== null) {
        other = sibling.previousSibling;
        $before.prepend($(sibling));
        sibling = other;
    }

    sibling = $node[0].nextSibling;
    while (sibling !== null) {
        other = sibling.nextSibling;
        $after.append($(sibling));
        sibling = other;
    }
    
    callback($before, $after);
    $('.word:empty').remove();
}

function updateWordWrap(updateAll) {
    var pageLeft = $('.page-inner').width();
    TextCursor.beginMove();
    
    var doWrap = function(index, element) {
        var $element = $(element);
        if ($element.position().left+$element.width() - 363 >  pageLeft) {
            $element.before('<br class="word-wrap"/>');   
        }
    };
    
    if (updateAll !== true) {
        $TextCursor.parent().nextAll('.word-wrap').remove();
        $($TextCursor.parent()[0].previousSibling).nextAll('.word').each(doWrap);
        TextCursor.endMove();
        return;
    }
    
    $('.word-wrap').remove();
    $('.word').each(doWrap);
}

var breaks = 1;
var nextMultiple = 0;
function updatePageBreaks(updateAll) {
    var pageHeight = 1056 - (96*2);
    
    var doBreaks = function(index, element) {
        $element = $(element);
        
        var elementBottom = $element.position().top+$element.height()-143;
        if (nextMultiple === 0) {
            nextMultiple = elementBottom;
            var remainder = nextMultiple % pageHeight;
            nextMultiple = nextMultiple + (pageHeight-remainder);
        }
        
        if(elementBottom > nextMultiple) {
            $element.before($('<div class="page-break"></div>'));
            breaks = breaks+1;
            
            nextMultiple = nextMultiple + pageHeight;
            
            $('.page').attr('style', 'min-height:'+(1056*breaks)+'px !important');
        }
    };
    
    if (updateAll !== true) {
        $TextCursor.parent().nextAll('.page-break').remove();
        $($TextCursor.parent()[0].previousSibling).nextAll('.word').each(doBreaks);
    } else {
        
    }
}

function HandleKey_Backspace(event) {
    event.preventDefault();
    /*
        First off check if there is a selection. If there is a selection
        remove all text nodes inside that selection then remove any empty word
        elements that may result from removing the text nodes.
    */
    var selection = rangy.getSelection();
    if (!selection.isCollapsed) {
        TextCursor.beginMove();
        //There is a selection
        var range = selection.getRangeAt(0);
        var rangeStart;
        range.deleteContents();
        range.setStart($TextCursor[0], 0);
        range.setEnd($TextCursor[0], 0);
        var wordElms = $('.word');
        $('.word:empty').remove();

        $parent = $TextCursor.parent();
        console.log($parent[0].previousSibling);
        if ($parent[0].previousSibling.nodeType === 1) {
            if ($parent[0].textContent === '') {
                $($parent[0].previousSibling).append($TextCursor);
                $parent.remove();
            }
            else {
                $sibling = $($parent[0].previousSibling);
                $sibling.append($parent.children());
            }
        }

        updateWordWrap(false);
        updatePageBreaks(false);
        console.log(range);
        //Ugly hack but sometimes backspacing on a selection removes everything ?? Other times it does not
        $('.page-inner:empty').html('<span class="word"><span class="textcursor"></span></span>');
        TextCursor.endMove();
        return;
    }

    /*
        This is a little bit messy.

        First of the content of the document is arranged by word elements
        <span class='word'> `text` </span>
        The word element has a text node for each character in the word and
        the $TextCursor is always inside of a word element, whethere it is between
        the characters or not.

        A space is between word elements in the form of &nbsp;

        Now it goes through checking if there is a character before the $TextCursor.
        If there is a character before it, the character gets removed. If there is no
        character there it then checks to see if the word containing the $TextCursor
        has a node before it which could be either a space (&nbsp;) or another word.

        If the node before it is not an element which means that it is a nbsp the space
        is removed and the $TextCursor is put inside the previous word after the
        last character in the word.

        If the node before is an element -- word element -- then move the $TextCursor
        inside the word and after the last character. It then removes the last character
        in that word.

        Lastly if there is only one word element in the whole document, don't remove it
        because it is needed when the user begins typing again.
    */
    TextCursor.beginMove();
    var prevSibling = $TextCursor[0].previousSibling;
    if (prevSibling !== null && prevSibling.textContent !== '') {
        $TextCursor[0].parentElement.removeChild(prevSibling);
    } else {
        prevSibling = $TextCursor[0].parentElement.previousSibling;
        var $parent = $TextCursor.parent();
        var removeParent = false;
        if (prevSibling !== null) {
            if ($(prevSibling).hasClass('tab')) {
                var todelete = prevSibling;
                prevSibling = prevSibling.previousSibling;
                $(prevSibling).append($TextCursor);
                $(todelete).remove();
            } else if (prevSibling.nodeType === 1 && prevSibling.tagName !== 'BR') {
               $(prevSibling).append($TextCursor);
                prevSibling = $TextCursor[0].previousSibling;
                if (prevSibling !== null)
                    $(prevSibling).remove();
                removeParent = true;
            } else if (prevSibling.tagName === 'BR') {
                $(prevSibling).remove();
            } else {
                var prevPrevSibling = prevSibling.previousSibling;
                $(prevSibling).remove();
                $(prevPrevSibling).append($TextCursor);
                removeParent = true;
            }

            if (removeParent && $parent[0].textContent === '' && $('.word').length !== 1)
                $parent.remove();
        }
    }
    TextCursor.endMove();
}

function HandleKey_Delete(event) {
    event.preventDefault();
}

function HandleKey_Space(event) {
    event.preventDefault();
    TextCursor.beginMove();
    $elm = $(Word_Element);

    splitAt($TextCursor, function($before, $after) {
        $before.after($elm);
        $elm.html('&nbsp;');
        $elm.addClass('space');
        $after.prepend($TextCursor);
        TextCursor.endMove();
    });
}

function HandleKey_Enter(event) {
    $newWord = $('<span class="word"></span>');
    $break = $('<br/>');
    splitAt($TextCursor, function($front, $end) {
        $end.prepend($TextCursor);
        $end.before($break);
    });
}

function HandleKey_Left(event) {
    event.preventDefault();
    TextCursor.moveLeft(1);
}

function HandleKey_Right(event) {
    event.preventDefault();
    TextCursor.moveRight(1);
}

function HandleKey_Tab(event) {
    event.preventDefault();
    TextCursor.beginMove();
    $Tab = $('<span class="tab">&nbsp;</span>');
    splitAt($TextCursor, function($before, $after) {
        $before.after($Tab);
        $after.prepend($TextCursor);
        TextCursor.endMove();
    });
    TextCursor.endMove();
}

/*
    Deletes the selected text if there is text selected.
*/
function DeleteSelection() {
    var sel = rangy.getSelection();
    if (!sel.isCollapsed) {
        sel.getRangeAt(0).deleteContents();
        $('.word:empty').remove();
    }
}

$(document).ready(function() {
    $('body').keydown(function(event) {
        switch(event.keyCode) {
            case Key_Left:
                HandleKey_Left(event);
                break;
                
            case Key_Right:
                HandleKey_Right(event);
                break;
                
            case Key_Up:
                event.preventDefault();
                break;
                
            case Key_Down:
                event.preventDefault();
                break;
                
            case Key_Space:
                DeleteSelection();
                HandleKey_Space(event);
                break;
                
            case Key_Enter:
                DeleteSelection();
                HandleKey_Enter(event);
                break;
                
            case Key_Backspace: 
                HandleKey_Backspace(event);
                break;
                
            case Key_Tab:
                DeleteSelection();
                HandleKey_Tab(event);
                break;
                
            default:
                DeleteSelection();
                TextCursor.beginMove();
                var letter = mapKey(event.shiftKey, event.keyCode);
                $TextCursor.before(CreateTextNode(letter));
                TextCursor.endMove();
                break;
        }
        
        /*
            These will handle word wraps and pagination after the current position of the caret.
        */
        updateWordWrap(false);
        updatePageBreaks(false);
    });
});